# 부록 A 추상화 기법

## 추상화 기법

**추상화 기법의 종류**

* 분류와 인스턴스화: `분류`는 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성한느 과정이다. 분류의 역은 범주로부터 객체를 생성하는 인스턴스화 과정이다.

* 일반화와 특수화: `일반화`는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다. 일반화의 역을 특수화라고 한다.

* 집합과 분해: 집합은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정을 가리킨다. 집합의 반대 과정은 전체를 부분으로 분리하는 `분해` 과정이다.

## 분류와 인스턴스화

### 개념과 범주

객체를 `분류`하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다. `개념`이란 `속성`과 `행위`가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어이다.

세상에 존재하는 객체에 `개념`을 적용하는 과정을 `분류`라고 한다. 분류는 특정한 개념을 나타내는 `집합`의 구성요소로 포함시킨다.

분류를 통해 개별 현상을 하나의 개념으로 다룬다. 이때 '수 많은 개별적인 현상'들을 `객체`라고 하고, '하나의 개념'을 `타입`이라고 한다. 분류는 객체를 타입과 연관시키는 것이다. 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 `인스턴스화` 또는 `예시`라고 한다.

객체지향 세계에서 개념을 가리키는 표준 용어는 `타입`이다. 분류란 객체들을 동일한 타입 또는 범주로 묶는 과정을 의미하므로 객체를 타입의 `인스턴스`라고 한다.

### 타입

타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요하다.

* 심볼: 타입을 가리키는 간략한 이름이나 명칭
* 내연: 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인
* 외연: 타입에 속하는 모든 객체들의 집합

### 외연과 집합

집합은 외연을 가리키는 또 다른 명칭이다. 객체들은 동시에 서로 다른 집합에 포함될 수 있다.

* 한 객체가 한 시점에 하나의 타입에만 속하는 것을 `단일 분류(single classfication)`이라고 한다. 
* 한 객체가 한 시점에 여러 타입에 속할 경우 이를 `다중 분류(multiple classfication)`이라고 한다.

대부분의 객체지향 프로그래밍 언어들은 단일 분류만 지원한다. 대부분의 언어에서 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개의 클래스의 인스턴스일 수 없다. 다중 분류는 다중 상속과는 다르다.

다중 상속은 하나의 타입이 다수의 슈퍼타입을 가질 수 있지만 타입 정의를 생략할 수는 없다. 다중 분류는 특정한 타입을 정의하지 않고도 하나의 객체가 서로 다른 타입의 인스턴스가 되도록 허용한다.

* 객체가 안 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우 이를 `동적 분류(dynamic classification)`이라고 한다. 
* 객체가 자신의 타입을 변경할 수 없는 경우 이를 `정적 분류(static classification)`라고 한다.

다중 분류와 동적 분류는 서로 배타적인 개념이 아니다. 대부분의 언어는 일단 클래스로부터 인스턴스를 생성한 후 클래스를 변경할 수 있는 방법을 제공하지 않는다. 즉, 객체의 타입을 변경할 수 없다. 따라서 우리가 사용하는 대부분의 언어는 정적 분류만 허용하며 동적 분류를 구현할 수 있는 방법을 제공하지 않는다.

단순함을 위해서는 항상 다중 분류와 동적 분류보다 단일 분류와 정적 분류를 선택하는 것이 현명하다.

### 클래스

`본질(essence)`이란 한 사물의 가장 핵심적이고 필수불가결한 속성이다. 본질적이지 않은 속성을 `우연적(accidental) 속성`이라고 한다.

`클래스`는 `객체`가 `공유`하는 `본질적인 속성`을 정의한다. 대부분의 객체지향 언어는 `본질적인 속성`을 표현할 수 있지만 `우연적인 속성`을 표현할 수 없다. 동일한 범주에 속하는 객체는 모두 동일한 속성을 가져야만 한다.

## 일반화와 특수화

### 범주의 계층

린네의 계층 구조는 좀 더 세부적인 범주가 계층의 하위에 위치하고 좀 더 일반적인 범주가 계층의 상위에 위치한다. 계층의 상위에 위치한 범주를 계층의 하위에 위치한 범주의 일반화라고 하고, 계층의 하위에 위치한 범주는 계층의 상위에 위치한 범주의 특수화라고 한다.

### 서브타입

일반화와 특수화는 계층 구조 안에 존재하는 타입 간의 관계를 의미한다. 

* 어떤 타입이 다른 타입보다 일반적이라면 이 타입을 슈퍼타입(supertype)이라고 한다.
* 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 서브타입(subtype)이라고 한다.

서브타입은 슈퍼타입의 본질적인 속성을 모두 포함하기 때문에 계층에 속하는 모든 서브타입들이 슈퍼타입의 속성을 공유한다는 것을 쉽게 예상할 수 있다.

**어떤 타입이 다른 타입의 서브타입이 되기 위한 두 가지 규칙**

* 100% 규칙: 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.

* is-a 규칙: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 이는 대게 영어로 서브타입은 슈퍼타입이다(subtype is a supertype)라는 구문을 만듦으로써 테스트할 수 있다.

### 상속

일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응(conformance)해야 한다. 

* 구조적인 순응: 기대 집합은 속성과 연관관계에 관한 것. 타입의 내연과 관련된 100% 규칙
* 행위적인 순응: 기대 집합은 행위가 동일한 계약을 기반으로 하느냐에 관한 것. 타입의 행위에 관한 것. `리스코프 치환 원칙(Liskov Substitution Principle, LSP)`라고 한다. 

상속의 또 다른 용도는 코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메커니즘 제공.

상속은 서브타이핑과 서브클래싱의 두 가지 용도로 사용될 수 있다.

* 서브타이핑(subtyping): 서브클래스가 슈퍼클래스를 대체할 수 있는 경우. 설계의 유연성이 목표. 인터페이스 상속(interface inheritance)
* 서브 클래싱(subclassing): 서브클래스가 슈퍼클래스를 대체할 수 없는 경우. 코드의 중복 제거와 재사용이 목적. 구현 상속(implementation inheritance)

상속은 서브타이핑을 프로그래밍 언어적으로 구현하는데 사용할 수 있지만 모든 상속이 서브타이핑인 것은 아니다. 서브클래스가 슈퍼클래스를 대체할 수 없고 단지 코드 공유하고 있다면 서브클래싱이다. 

가능한 모든 상속 관계가 서브타이핑의 대체 가능성을 준수하도록 주의 깊게 사용하는 것은 코드를 유연하게 만들고 재사용성을 높이는 한 가지 방법이다.

클래스 간의 위임 사슬은 계층 내의 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에 위임될 때 까지 계속된다.

## 집합과 분해

### 계층적인 복잡성

* 복잡성은 '계층'의 형태를 띤다.
* 단순한 형태로부터 복합한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 '안정적인 형태'의 수와 분포에 의존한다.

객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 `합성 관계`를 사용한다. `합성 관계`는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.

연관 관계로 연결된 두 객체는 독립적으로 제거될 수 있다. 합성 관계는 생명주기 측면에서 연관 관계보다 더 강하게 객체들을 결합한다.

### 패키지

상공에서 바라본 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 하나의 논리적인 단위로 묶는 구성 요소를 패키지(package) 또는 모듈(module)이라고 한다.

합성 관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화하는 것처럼 패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다.

---

## References.

조영호, 『객체지향의 사실과 오해』, 위키북스(2015), p229-250.
