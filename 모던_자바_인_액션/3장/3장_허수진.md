# ch3 람다 표현식

람다 표현식은 학교 수업 때 이승진 교수님께서 종종 (꼭 알아야한다며.. 코드의 질이 달라진다며) 강조하셨던 문법이었다.

이 책을 통해 한걸음 가까워질 수 있길 희망한다.

---

## 람다란 무엇인가?

메서드로 전달할 수 있는 익명 함수를 단순화한 것이다. 

람다의 특징은 `1)익명, 2)함수 3)전달 4) 간결성` 이 있다.

또한 커스텀 Comparator 갹체를 기존보다 간단하게 구현할 수 있다. 

```java
Comparator<Apple> byWeight = new Comparator<Apple>() {
  public int compare(Apple a1, Apple a2) {
    return a1.getWeight().compareTo(a2.getWeight());
  }
};

// 람다를 이용하면?

Comparator<Apple> byWeight =
 (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```

위처럼 엄청 간단하게 구현할 수 있다.



### 람다의 표현식

- 파라미터 리스트

  Comparator 의 compare 메서드 파라미터를 여기서는 사과 두개로 표현했다.

- 화살표

  화살표는 람다의` 파라미터 리스트`와` 바디`를 구분한다.

- 람다 바디

  람다의 반환값에 해당하는 표현식 예제다.

![스크린샷 2021-11-10 오후 3.44.09](/Users/sujinheo/Desktop/스크린샷 2021-11-10 오후 3.44.09.png)



람다 표현식에는 기본적으로 리턴한다는 조건이 전제로 있다.

### 람다 예제

|     사용 사례      | 람다 예제                                                    |
| :----------------: | ------------------------------------------------------------ |
|   불리언 표현식    | (List<String) -> list.isEmpty( );                            |
|     객체 생성      | ( ) -> new Apple(10);                                        |
|   객체에서 소비    | (Apple a) -> { System.out.println(a.getWeight()); }          |
| 객체에서 선택/추출 | (String s) -> s.lenght( );                                   |
|    두 값을 조합    | (int a, int b) -> a * b ;                                    |
|    두 객체 비교    | (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()); |



## 어디에 어떻게 람다를 사용할까?

함수형 인터페이스라는 문맥에서 람다 표현식으로 사용할 수 있다. 

아래 예제에서는 함수형 인터페이스 Predicate<T> 를 기대하는 filter 메서드의 두 번째 인수로 람다 표현식을 전달했다.



### 함수형 인터페이스

```java 
public interface Predicate<T> {
  boolean test (T t);
} // 많은 디폴트 메서드가 있더라도 추상 메서드가 오직 하나면 함수형 인터페이스이다.
```



함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 전체 표현식을 함수형 인터페이스의 인스턴스로 취급할 수 있다. 



## 함수 디스크립터

함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다.

표현식의 시그니처를 서술하는 메서드를 함수 디스크립터라고 부른다. 



## 중간 정리

람다 표현식은 변수에 할당하거나 함수형 인터페이스를 인수로 받는 메서드로 전달할 수 있으며, 

함수형 인터페이스의 추상 메서드와 같은 시그니처를 갖는다는 사실을 기억하자

---



## 람다와 메서드 호출

한개의 메소드 호출은 중괄호로 감쌀필요 없고, 두개부터는 감싸야함???????????????

```java
process(() -> System.out.println("awesome"))
process(() -> {System.out.println("awesome");})
```



----

## 람다 활용 : 실행 어라운드 패턴

Try-with-resources 구문을 사용하면 자원을 명시적으로 닫을 필요 없어 간결한 코드에 도움을 준다.

초기화/준비코드 - 작업 - 정리/마무리코드

```java
public String processFile() throws IOException {
  try (BufferedReader br =
      new BufferedReader(new FileReader("data.txt"))) {
    return br.readLine();
  }
}
```



---



## 1단계 : 동작 파라미터화를 기억하라

한번에 두 줄을 읽거나 자주 사용되는 단어를 반환하려면 어떻게 해야할까? 

```java
String result = processFile((BufferedReader br) -> br.readLine() + br.readLine());
```



## 2단계 : 함수형 인터페이스를 이용해서 동작 전달

함수형 인페 자리에 람다를 사용할 수 있다. 시그니처와 일치하는 함수형 인터페이스를 만들어야한다. 

이 인터페이스를 만들어야한다. 이 인터페이스를 BufferedReaderProcessor 라고 정의하자.

``` java
// 정의한 인터페이스를 ProcessFile 메서드의 인수로 전달할 수 있다.
@FunctionalInterface
public interface BufferedReaderProcessor {
  String process(BufferedReader b) throws IOException;
}

public String processFile(BufferedReaderProcessor p) throw IOException {};
```



## 3단계: 동작 실행

이제 위에 정의된 process 메서드의 시그니처(BufferedReader - String) 과 일치하는 람다를 전달할 수 있다. 

람다의 코드가 processFile 내부에서 어떻게 실행되는지 기억하고 있는가?

람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할수 있으며, 전달된 코드는 함수형 인터페이스의 인스턴스로 전달된 코드와 같은 방식으로 처리한다. 

따라서 processFile 바니 내에서 BufferedReaderProcessor 객체의 process를 호출할 수 있다.

```java
public String processFile(BufferedReaderProcessor p) throws IOEception {
  try (BufferedReader br = new BufferedReader(new FileReader("data.txt"))) {
    return p.process(br); // 객체 예외처리
  }
}  
```



## 4단계 : 람다 전달

이제 람다를 이용해서 다양한 동작을 processFile 메서드로 전달할 수 있다. 

다음은 한 행을 처리하는 코드다

```java 
String oneLine = processFile((BufferedReader br) -> br.readLine());
```

